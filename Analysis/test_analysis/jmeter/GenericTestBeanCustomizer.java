/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generated by EvoSuite 1.2.0
 */
package org.apache.jmeter.testbeans.gui;

import java.awt.Component;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.beans.BeanInfo;
import java.beans.PropertyDescriptor;
import java.beans.PropertyEditor;
import java.beans.PropertyEditorManager;
import java.io.Serializable;
import java.text.MessageFormat;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Map;
import java.util.ResourceBundle;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.SwingConstants;

import org.apache.commons.lang3.ClassUtils;
import org.apache.jmeter.gui.ClearGui;
import org.apache.jmeter.testbeans.TestBeanHelper;
import org.apache.jmeter.util.JMeterUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class GenericTestBeanCustomizer extends JPanel implements SharedCustomizer {
    private static final long serialVersionUID = 241L;

    private static final Logger log = LoggerFactory.getLogger(GenericTestBeanCustomizer.class);

    
    
    
    static {
        PropertyEditorManager.registerEditor(Long.class,    LongPropertyEditor.class);
        PropertyEditorManager.registerEditor(Integer.class, IntegerPropertyEditor.class);
        PropertyEditorManager.registerEditor(Boolean.class, BooleanPropertyEditor.class);
    }

    public static final String GROUP = "group"; 

    public static final String ORDER = "order"; 

    
    public static final String TAGS = "tags"; 

    
    public static final String NOT_UNDEFINED = "notUndefined"; 

    
    public static final String NOT_EXPRESSION = "notExpression"; 

    
    public static final String NOT_OTHER = "notOther"; 

    
    public static final String MULTILINE = "multiline";

    
    public static final String DEFAULT = "default"; 

    
    public static final String DEFAULT_NOT_SAVED = "defaultNoSave"; 

    
    public static final String RESOURCE_BUNDLE = "resourceBundle"; 

    
    public static final String GUITYPE = "guiType"; 

    
    public static final String TEXT_LANGUAGE = "textLanguage"; 

    public static String ORDER(String group) {
        return "group." + group + ".order";
    }

    public static final String DEFAULT_GROUP = "";

    @SuppressWarnings("unused") 
    private int scrollerCount = 0;

    
    private transient BeanInfo beanInfo;

    
    private transient PropertyDescriptor[] descriptors;

    
    private transient PropertyEditor[] editors;

    
    private MessageFormat propertyFieldLabelMessage;

    
    private MessageFormat propertyToolTipMessage;

    
    private Map<String, Object> propertyMap;

    
    @Deprecated
    public GenericTestBeanCustomizer(){
        log.warn("Constructor only intended for use in testing"); 
    }
    
    GenericTestBeanCustomizer(BeanInfo beanInfo) {
        super();

        this.beanInfo = beanInfo;

        
        descriptors = beanInfo.getPropertyDescriptors();
        Arrays.sort(descriptors, new PropertyComparator(beanInfo));

        
        editors = new PropertyEditor[descriptors.length];
        int scriptLanguageIndex = 0;
        int textAreaEditorIndex = 0;
        for (int i = 0; i < descriptors.length; i++) { 
            PropertyDescriptor descriptor = descriptors[i];
            String name = descriptor.getName();

            
            if (TestBeanHelper.isDescriptorIgnored(descriptor)) {
                log.debug("Skipping editor for property {}", name);
                editors[i] = null;
                continue;
            }

            PropertyEditor propertyEditor;
            Object guiType = descriptor.getValue(GUITYPE);
            if (guiType instanceof TypeEditor) {
                propertyEditor = ((TypeEditor) guiType).getInstance(descriptor);
            } else if (guiType instanceof Class && Enum.class.isAssignableFrom((Class<?>) guiType)) {
                    @SuppressWarnings("unchecked") 
                    final Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) guiType;
                    propertyEditor = new EnumEditor(descriptor, enumClass, (ResourceBundle) descriptor.getValue(GenericTestBeanCustomizer.RESOURCE_BUNDLE));
            } else {
                Class<?> editorClass = descriptor.getPropertyEditorClass();
                log.debug("Property {} has editor class {}", name, editorClass);

                if (editorClass != null) {
                    try {
                        propertyEditor = (PropertyEditor) editorClass.getDeclaredConstructor().newInstance();
                    } catch (ReflectiveOperationException e) {
                        log.error("Can't create property editor.", e);
                        throw new Error(e.toString());
                    }
                } else {
                    Class<?> c = descriptor.getPropertyType();
                    propertyEditor = PropertyEditorManager.findEditor(c);
                }
            }

            if (propertyEditor == null) {
                if (log.isWarnEnabled()) {
                    log.warn("No editor for property: {} type: {} in bean: {}", name, descriptor.getPropertyType(),
                            beanInfo.getBeanDescriptor().getDisplayName());
                }
                editors[i] = null;
                continue;
            }

            log.debug("Property {} has property editor {}", name, propertyEditor);

            validateAttributes(descriptor, propertyEditor);

            if (!propertyEditor.supportsCustomEditor()) {
                propertyEditor = createWrapperEditor(propertyEditor, descriptor);
                log.debug("Editor for property {} is wrapped in {}", name, propertyEditor);
            }
            if(propertyEditor instanceof TestBeanPropertyEditor)
            {
                ((TestBeanPropertyEditor)propertyEditor).setDescriptor(descriptor);
            }

            if (propertyEditor instanceof TextAreaEditor) {
                textAreaEditorIndex = i;
            }
            if (propertyEditor.getCustomEditor() instanceof JScrollPane) {
                scrollerCount++;
            }

            editors[i] = propertyEditor;

            
            setEditorValue(i, descriptor.getValue(DEFAULT));

            if (name.equals("scriptLanguage")) {
                scriptLanguageIndex = i;
            }

        }
        
        String beanName = this.beanInfo.getBeanDescriptor().getName();
        if (beanName.startsWith("BSF") || beanName.startsWith("JSR223")) { 
            WrapperEditor we = (WrapperEditor) editors[scriptLanguageIndex];
            TextAreaEditor tae = (TextAreaEditor) editors[textAreaEditorIndex];
            we.addChangeListener(tae);
        }

        
        propertyFieldLabelMessage = new MessageFormat(JMeterUtils.getResString("property_as_field_label")); 
        propertyToolTipMessage = new MessageFormat(JMeterUtils.getResString("property_tool_tip")); 

        
        init();
    }

    
    @SuppressWarnings("JdkObsolete")
    private static void validateAttributes(PropertyDescriptor pd, PropertyEditor pe) {
        final Object deflt = pd.getValue(DEFAULT);
        if (deflt == null) {
            if (notNull(pd)) {
                if (log.isWarnEnabled()) {
                    log.warn("{} requires a value but does not provide a default.", getDetails(pd));
                }
            }
            if (noSaveDefault(pd)) {
                if (log.isWarnEnabled()) {
                    log.warn("{} specifies DEFAULT_NO_SAVE but does not provide a default.", getDetails(pd));
                }
            }
        } else {
            final Class<?> defltClass = deflt.getClass(); 
            
            final Class<?> propClass = ClassUtils.primitiveToWrapper(pd.getPropertyType());
            if (!propClass.isAssignableFrom(defltClass) ){
                if (log.isWarnEnabled()) {
                    log.warn("{} has a DEFAULT of class {}", getDetails(pd), defltClass.getCanonicalName());
                }
            }
        }
        if (notOther(pd) && pd.getValue(TAGS) == null && pe.getTags() == null) {
            if (log.isWarnEnabled()) {
                log.warn("{} does not have tags but other values are not allowed.", getDetails(pd));
            }
        }
        if (!notNull(pd)) {
            Class<?> propertyType = pd.getPropertyType();
            if (propertyType.isPrimitive()) {
                if (log.isWarnEnabled()) {
                    log.warn("{} allows null but is a primitive type", getDetails(pd));
                }
            }
        }
        if (!pd.attributeNames().hasMoreElements()) {
            if (log.isWarnEnabled()) {
                log.warn("{} does not appear to have been configured", getDetails(pd));
            }
        }
    }

    
    private static String getDetails(PropertyDescriptor pd) {
        return pd.getReadMethod().getDeclaringClass().getName() + '#'
                + pd.getName() + '(' + pd.getPropertyType().getCanonicalName()
                + ')';
    }

    
    private static WrapperEditor createWrapperEditor(PropertyEditor typeEditor, PropertyDescriptor descriptor) {
        String[] editorTags = typeEditor.getTags();
        String[] additionalTags = (String[]) descriptor.getValue(TAGS);
        String[] tags;
        if (editorTags == null) {
            tags = additionalTags;
        } else if (additionalTags == null) {
            tags = editorTags;
        } else {
            tags = new String[editorTags.length + additionalTags.length];
            int j = 0;
            for (String editorTag : editorTags) {
                tags[j++] = editorTag;
            }
            for (String additionalTag : additionalTags) {
                tags[j++] = additionalTag;
            }
        }

        boolean notNull = notNull(descriptor);
        boolean notExpression = notExpression(descriptor);
        boolean notOther = notOther(descriptor);

        PropertyEditor guiEditor;
        if (notNull && tags == null) {
            guiEditor = new FieldStringEditor();
        } else {
            guiEditor = new ComboStringEditor(tags, notExpression && notOther, notNull,
                    (ResourceBundle) descriptor.getValue(GenericTestBeanCustomizer.RESOURCE_BUNDLE));
        }

        return new WrapperEditor(typeEditor, guiEditor,
                !notNull, 
                !notExpression, 
                !notOther, 
                descriptor.getValue(DEFAULT));
    }

    
    static boolean notOther(PropertyDescriptor descriptor) {
        return Boolean.TRUE.equals(descriptor.getValue(NOT_OTHER));
    }

    
    static boolean notExpression(PropertyDescriptor descriptor) {
        return Boolean.TRUE.equals(descriptor.getValue(NOT_EXPRESSION));
    }

    
    static boolean notNull(PropertyDescriptor descriptor) {
        return Boolean.TRUE.equals(descriptor.getValue(NOT_UNDEFINED));
    }

    
    static boolean noSaveDefault(PropertyDescriptor descriptor) {
        return Boolean.TRUE.equals(descriptor.getValue(DEFAULT_NOT_SAVED));
    }

    
    private void setEditorValue(int i, Object value) throws IllegalArgumentException {
        editors[i].setValue(value);
    }


    
    @SuppressWarnings("unchecked")
    @Override
    public void setObject(Object map) {
        propertyMap = (Map<String, Object>) map;

        if (propertyMap.isEmpty()) {
            
            for (PropertyDescriptor descriptor : descriptors) {
                Object value = descriptor.getValue(DEFAULT);
                String name = descriptor.getName();
                if (value != null) {
                    propertyMap.put(name, value);
                    log.debug("Set {}={}", name, value);
                }
                firePropertyChange(name, null, value);
            }
        }

        
        for (int i = 0; i < editors.length; i++) {
            if (editors[i] == null) {
                continue;
            }
            try {
                setEditorValue(i, propertyMap.get(descriptors[i].getName()));
            } catch (IllegalArgumentException e) {
                
                
                
                
                
                
                
                
                
                
                
                
                
                setEditorValue(i, descriptors[i].getValue(DEFAULT));
            }
        }
    }

    
    private void init() { 
        setLayout(new GridBagLayout());

        GridBagConstraints cl = new GridBagConstraints(); 
        cl.gridx = 0;
        cl.anchor = GridBagConstraints.EAST;
        cl.insets = new Insets(0, 1, 0, 1);

        GridBagConstraints ce = new GridBagConstraints(); 
        ce.fill = GridBagConstraints.BOTH;
        ce.gridx = 1;
        ce.weightx = 1.0;
        ce.insets = new Insets(0, 1, 0, 1);

        GridBagConstraints cp = new GridBagConstraints(); 
        cp.fill = GridBagConstraints.BOTH;
        cp.gridx = 1;
        cp.gridy = GridBagConstraints.RELATIVE;
        cp.gridwidth = 2;
        cp.weightx = 1.0;

        JPanel currentPanel = this;
        String currentGroup = DEFAULT_GROUP;
        int y = 0;

        for (int i = 0; i < editors.length; i++) {
            if (editors[i] == null) {
                continue;
            }

            if (log.isDebugEnabled()) {
                log.debug("Laying property {}", descriptors[i].getName());
            }

            String g = group(descriptors[i]);
            if (!currentGroup.equals(g)) {
                if (currentPanel != this) {
                    add(currentPanel, cp);
                }
                currentGroup = g;
                currentPanel = new JPanel(new GridBagLayout());
                currentPanel.setBorder(BorderFactory.createTitledBorder(groupDisplayName(g)));
                cp.weighty = 0.0;
                y = 0;
            }

            Component customEditor = editors[i].getCustomEditor();

            boolean multiLineEditor = false;
            if (customEditor.getPreferredSize().height > 50 || customEditor instanceof JScrollPane
                    || descriptors[i].getValue(MULTILINE) != null) {
                
                
                
                
                multiLineEditor = true;
            }

            JLabel label = createLabel(descriptors[i]);
            label.setLabelFor(customEditor);

            cl.gridy = y;
            cl.gridwidth = multiLineEditor ? 2 : 1;
            cl.anchor = multiLineEditor ? GridBagConstraints.CENTER : GridBagConstraints.EAST;
            currentPanel.add(label, cl);

            ce.gridx = multiLineEditor ? 0 : 1;
            ce.gridy = multiLineEditor ? ++y : y;
            ce.gridwidth = multiLineEditor ? 2 : 1;
            ce.weighty = multiLineEditor ? 1.0 : 0.0;

            cp.weighty += ce.weighty;

            currentPanel.add(customEditor, ce);

            y++;
        }
        if (currentPanel != this) {
            add(currentPanel, cp);
        }

        
        
        cp.weighty = 0.0001;
        add(Box.createHorizontalStrut(0), cp);
    }

    private JLabel createLabel(PropertyDescriptor desc) {
        String text = desc.getDisplayName();
        if (!"".equals(text)) {
            text = propertyFieldLabelMessage.format(new Object[] { desc.getDisplayName() });
        }
        
        JLabel label = new JLabel(text);
        label.setHorizontalAlignment(SwingConstants.TRAILING);
        label.setToolTipText(propertyToolTipMessage.format(new Object[] { desc.getShortDescription() }));

        return label;
    }

    
    private static String group(PropertyDescriptor descriptor) {
        String group = (String) descriptor.getValue(GROUP);
        if (group == null){
            group = DEFAULT_GROUP;
        }
        return group;
    }

    
    private String groupDisplayName(String group) {
        ResourceBundle b = (ResourceBundle) beanInfo.getBeanDescriptor().getValue(RESOURCE_BUNDLE);
        if (b == null) {
            return group;
        }
        String key = group + ".displayName";
        if (b.containsKey(key)) {
            return b.getString(key);
        } else {
            return group;
        }
    }

    
    private static class PropertyComparator implements Comparator<PropertyDescriptor>, Serializable {
        private static final long serialVersionUID = 240L;

        private final BeanInfo beanInfo;
        public PropertyComparator(BeanInfo beanInfo) {
            this.beanInfo = beanInfo;
        }

        @Override
        public int compare(PropertyDescriptor d1, PropertyDescriptor d2) {
            String g1 = group(d1);
            String g2 = group(d2);
            Integer go1 = groupOrder(g1);
            Integer go2 = groupOrder(g2);

            int result = go1.compareTo(go2);
            if (result != 0) {
                return result;
            }

            result = g1.compareTo(g2);
            if (result != 0) {
                return result;
            }

            Integer po1 = propertyOrder(d1);
            Integer po2 = propertyOrder(d2);
            result = po1.compareTo(po2);
            if (result != 0) {
                return result;
            }

            return d1.getName().compareTo(d2.getName());
        }

        
        private Integer groupOrder(String group) {
            Integer order = (Integer) beanInfo.getBeanDescriptor().getValue(ORDER(group));
            if (order == null) {
                order = 0;
            }
            return order;
        }

        
        private static Integer propertyOrder(PropertyDescriptor d) {
            Integer order = (Integer) d.getValue(ORDER);
            if (order == null) {
                order = 0;
            }
            return order;
        }
    }

    
    void saveGuiFields() {
        for (int i = 0; i < editors.length; i++) {
            PropertyEditor propertyEditor=editors[i]; 
            if (propertyEditor != null) {
                Object value = propertyEditor.getValue();
                String name = descriptors[i].getName();
                if (value == null) {
                    propertyMap.remove(name);
                    log.debug("Unset {}", name);
                } else {
                    propertyMap.put(name, value);
                    log.debug("Set {}={}", name, value);
                }
            }
        }
    }

    void clearGuiFields() {
        for (int i = 0; i < editors.length; i++) {
            PropertyEditor propertyEditor=editors[i]; 
            if (propertyEditor != null) {
                try {
                if (propertyEditor instanceof ClearGui) {
                    ((ClearGui) propertyEditor).clearGui();
                } else if (propertyEditor instanceof WrapperEditor){
                    WrapperEditor we = (WrapperEditor) propertyEditor;
                    String[] tags = we.getTags();
                    if (tags != null && tags.length > 0) {
                        we.setAsText(tags[0]);
                    } else {
                        we.resetValue();
                    }
                } else {
                    propertyEditor.setAsText("");
                }
                } catch (IllegalArgumentException ex){
                    log.error("Failed to set field {}", descriptors[i].getName(), ex);
                }
            }
        }
    }

}
